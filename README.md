Taller 2

Arquitectura 

<img width="870" height="607" alt="Captura de Pantalla 2025-10-31 a la(s) 9 34 14 p m" src="https://github.com/user-attachments/assets/76d78288-34a8-4c7f-a269-0a9f3fff83a1" />

En el Taller 2 de Sistemas Distribuidos desarrollamos una arquitectura orientada a la implementación de un sistema distribuido con replicación de datos, tolerancia a fallos y balanceo de carga. El sistema permite que múltiples clientes web registren sus nombres, los cuales se almacenan en una estructura replicada entre varios nodos backend. Esta solución está diseñada para funcionar de manera robusta en entornos dinámicos, donde los nodos pueden fallar o incorporarse en tiempo de ejecución sin comprometer la integridad del sistema.
La arquitectura se compone de cinco elementos principales: el cliente web asíncrono, el balanceador de carga, el registro de servicios (ServerRegistry), los nodos backend y la estructura de datos replicada. El cliente está desarrollado en JavaScript y utiliza llamadas HTTP asíncronas (por ejemplo, mediante `fetch`) para interactuar con el sistema sin necesidad de recargar la página. Este cliente no se comunica directamente con los nodos backend, sino que envía sus solicitudes al balanceador de carga.

El balanceador de carga está implementado en Java usando Spring Boot. Su función es distribuir las solicitudes entrantes entre los nodos backend disponibles, utilizando una estrategia de round-robin para garantizar una distribución equitativa. Esto evita que un solo nodo se sobrecargue y mejora la disponibilidad general del sistema. Internamente, el balanceador utiliza un componente de servicio que consulta el registro de nodos activos para decidir a cuál redirigir cada solicitud.
El ServerRegistry es el componente encargado de mantener actualizada la lista de nodos backend disponibles. Cada vez que un nodo se inicia, se registra automáticamente en este componente. Si un nodo falla o se desconecta, el registro lo elimina de la lista. El balanceador de carga consulta este registro constantemente para tomar decisiones de enrutamiento.

Los nodos backend son instancias independientes que también corren sobre Spring Boot. Cada uno expone un servicio REST que permite registrar nombres y consultarlos. Lo más importante es que cada nodo mantiene una copia sincronizada de la estructura de datos principal: un `ReplicatedHashMap`. Esta estructura se sincroniza entre nodos utilizando la biblioteca JGroups, que permite la comunicación en grupo. Cuando un nodo inserta un nuevo dato (por ejemplo, un nombre con su timestamp), los demás nodos reciben la actualización automáticamente. Esto asegura que todos los nodos compartan el mismo estado sin necesidad de una base de datos centralizada.
El comportamiento del sistema sigue una secuencia clara: el cliente envía una solicitud para registrar un nombre, el balanceador la recibe y la redirige a uno de los nodos backend activos. El nodo seleccionado guarda el dato en su estructura replicada, y JGroups se encarga de propagarlo a los demás nodos. Si algún nodo falla, los demás continúan funcionando con la información replicada. Si un nuevo nodo se une al sistema, recibe automáticamente una copia completa del estado actual desde uno de los nodos existentes.

En cuanto a la estructura del proyecto, se divide en dos módulos principales: `backend/` y `loadbalancer/`. El módulo `backend/` contiene todo lo relacionado con los nodos replicados, incluyendo la lógica de comunicación con JGroups y el servicio REST. Las clases más relevantes en este módulo son `BackendApplication.java`, que inicia el servicio; `RegistryController.java`, que expone los endpoints REST; y `SimpleChat.java`, que implementa la lógica de replicación con JGroups. También se incluye una clase de prueba llamada `TestJGroupsVersion.java`, útil para verificar la conectividad entre nodos.
Por otro lado, el módulo `loadbalancer/` contiene el balanceador de carga, el registro de nodos y la interfaz web. Las clases clave aquí son `LoadBalancerApplication.java`, que inicia el servidor; `LoadBalancerController.java`, que maneja las solicitudes del cliente; `LoadBalancerService.java`, que implementa la lógica de distribución de carga; y `NodeRegistryController.java`, que gestiona el registro dinámico de nodos. Este módulo también incluye el archivo `index.html`, que representa el cliente web y se encuentra en la carpeta `static/`.

Finalmente, el proyecto incluye archivos de configuración como `pom.xml` para definir las dependencias (Spring Boot, JGroups, etc.), `application.properties` para establecer puertos y direcciones, y los archivos `.jar` generados en la carpeta `target/` para desplegar cada servicio. También se utilizan claves `.pem` para habilitar comunicación segura entre nodos si se configura TLS.
En resumen, cada componente del sistema está claramente mapeado con su implementación en el código. El cliente web corresponde al archivo `index.html`, el balanceador de carga y su lógica están en las clases `LoadBalancerApplication`, `LoadBalancerController` y `LoadBalancerService`, el registro de servicios se encuentra en `NodeRegistryController`, y los nodos backend con su estructura replicada están implementados en `BackendApplication`, `RegistryController` y `SimpleChat`. La replicación se logra gracias a JGroups, cuya biblioteca está incluida como `jgroups-5.0.0.Final.jar`.


Còdigo

Proyecto Backend

Clases:
1. Application: Esta clase es la entrada principal de una aplicación backend construida con Spring Boot, y su propósito es iniciar el servidor y establecer la comunicación distribuida entre nodos. Al ejecutarse, Spring Boot arranca el servicio web, y mediante el método anotado con `@PostConstruct`, se invoca `simpleChat.initChannel()`, que activa el canal de JGroups para que el nodo se una al grupo de replicación. Esto permite que, desde el inicio, el nodo esté sincronizado con los demás y pueda enviar o recibir actualizaciones de datos en tiempo real, asegurando que todos los nodos compartan el mismo estado sin depender de una base de datos central.
2. 
